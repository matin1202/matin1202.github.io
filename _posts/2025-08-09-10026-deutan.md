---
layout: post
title: "10026번 적녹색약"
subtitle: "c++, BFS"
date: 2025-08-09 00:00:00 +0900
background: ""
---
{% link_preview "https://www.acmicpc.net/problem/10026" %}

## 풀이
이 문제는 적록색약인 사람과 그렇지 않은 사람이 보는 그림에서 각각의 구역의 수를 세는 문제입니다. BFS (Breadth-First Search)를 사용하여 연결된 구성 요소의 수를 계산하는 방식으로 해결할 수 있습니다.

1. **두 가지 보드 준비**:
   - 일반적인 경우를 위한 `board`: 'R', 'G', 'B'를 각각 다른 숫자로 매핑합니다. (예: R=1, G=2, B=3)
   - 적록색약인 경우를 위한 `board_week`: 'R'과 'G'를 같은 숫자로 매핑하고 'B'는 다른 숫자로 매핑합니다. (예: R=1, G=1, B=3)

2. **BFS 함수 구현**:
   - `BFS(board, visited, x, y)` 함수는 주어진 `(x, y)` 좌표에서 시작하여 동일한 색상을 가진 모든 인접한 셀을 탐색합니다.
   - `visited` 배열을 사용하여 이미 방문한 셀을 추적하여 중복 계산을 방지합니다.
   - 큐를 사용하여 BFS 탐색을 수행하고, 현재 셀의 색상과 동일한 인접 셀을 큐에 추가하고 방문 처리합니다.

3. **구역 수 계산**:
   - 두 개의 별도의 `visited` 배열(`visited` 및 `visited_week`)을 사용하여 일반적인 경우와 적록색약인 경우를 각각 추적합니다.
   - 두 개의 카운터(`cnt` 및 `cnt_week`)를 0으로 초기화합니다.
   - 전체 보드를 순회하면서:
     - 만약 현재 셀이 일반 `visited` 배열에서 방문되지 않았다면, `BFS(board, visited, i, j)`를 호출하고 `cnt`를 1 증가시킵니다.
     - 만약 현재 셀이 적록색약 `visited_week` 배열에서 방문되지 않았다면, `BFS(board_week, visited_week, i, j)`를 호출하고 `cnt_week`를 1 증가시킵니다.

4. **결과 출력**:
   - 최종적으로 `cnt`와 `cnt_week`를 출력합니다.

이 방법은 두 가지 다른 관점에서 그림의 연결된 구성 요소를 효율적으로 계산하여 문제를 해결합니다.

## 코드
{% wandbox lang="cpp" file="9019.cpp" stdin_visible="true" %}
---STDIN---
5
RRRBB
GGBBB
BBBRR
BBRRR
RRRRR
{% endwandbox %}
