---
layout: post
title: "9019번 DSLR"
subtitle: "c++, BFS"
date: 2025-08-09 00:00:00 +0900
background: ""
---
{% link_preview "https://www.acmicpc.net/problem/9019" %}

## 풀이

9019번 DSLR 문제는 두 정수 A에서 B로 변환하기 위한 최소한의 DSLR 연산 순서를 찾는 문제입니다. 이는 전형적인 최단 경로 문제이며, 너비 우선 탐색(BFS)을 통해 해결할 수 있습니다.

**BFS 접근 방식:**

1.  **상태 정의:** BFS의 각 상태는 현재 숫자와 해당 숫자에 도달하기까지 사용된 연산 문자열의 쌍 `(현재 숫자, 연산 문자열)`으로 정의합니다.

2.  **연산 정의:**
    *   **D (Double):** `n = (2 * n) % 10000`
        *   숫자를 두 배로 늘립니다. 결과가 9999보다 크면 10000으로 나눈 나머지를 취합니다.
    *   **S (Subtract):** `n = (--n < 0?9999:n)`
        *   숫자에서 1을 뺍니다. 결과가 0 미만인 경우 9999로 설정합니다.
    *   **L (Left Shift):** `n = (n % 1000) * 10 + n / 1000`
        *   숫자를 왼쪽으로 회전시킵니다. 예를 들어, 1234는 2341이 됩니다.
        *   이는 `(n을 1000으로 나눈 나머지) * 10` (뒤 세 자리를 땡겨오고 0을 붙임) 에 `n을 1000으로 나눈 몫` (맨 앞자리를 맨 뒤로 보냄)을 더하는 방식으로 구현할 수 있습니다.
    *   **R (Right Shift):** `n = (n / 10) + (n % 10) * 1000`
        *   숫자를 오른쪽으로 회전시킵니다. 예를 들어, 1234는 4123이 됩니다.
        *   이는 `(n을 10으로 나눈 몫)` (맨 앞 세 자리를 유지) 에 `(n을 10으로 나눈 나머지) * 1000` (맨 뒷자리를 맨 앞으로 보냄)을 더하는 방식으로 구현할 수 있습니다.

3.  **BFS 구현:**
    *   **큐(Queue) 사용:** BFS 탐색을 위해 큐를 사용합니다. 큐에는 `(현재 숫자, 연산 문자열)` 쌍을 저장합니다.
    *   **방문 배열(Visited Array):** 이미 방문한 숫자를 기록하기 위해 `boolean` 배열 또는 `set` 형태의 `visited` 배열을 사용합니다. `visited[num]`은 `num`에 도달하기 위한 최단 연산 문자열을 저장하거나, 단순히 방문 여부만을 기록할 수 있습니다. 중복 계산 및 무한 루프를 방지합니다.
    *   **초기 상태:** 큐에 `(시작 숫자 A, "")`를 삽입하고, `visited[A]`를 초기화합니다.
    *   **탐색 과정:**
        1.  큐에서 `(현재 숫자, 현재 연산 문자열)`을 하나 꺼냅니다.
        2.  `현재 숫자`가 `목표 숫자 B`와 같다면, `현재 연산 문자열`이 정답이므로 반환하고 탐색을 종료합니다.
        3.  `현재 숫자`에 대해 네 가지 DSLR 연산(D, S, L, R)을 각각 적용하여 `다음 숫자`를 계산합니다.
        4.  각 `다음 숫자`에 대해:
            *   만약 `다음 숫자`가 아직 방문하지 않은 숫자라면 (`visited` 배열에서 확인),
            *   `visited[다음 숫자]`를 `현재 연산 문자열 + 해당 연산 문자`로 업데이트하고,
            *   큐에 `(다음 숫자, 현재 연산 문자열 + 해당 연산 문자)`를 삽입합니다.

## 코드
{% wandbox lang="cpp" file="9019.cpp" stdin_visible="true" %}
---STDIN---
3
1234 3412
1000 1
1 16
{% endwandbox %}
